<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="Generator" content="EditPlusÂ®">
  <meta name="Author" content="">
  <meta name="Keywords" content="">
  <meta name="Description" content="">
  <title>Hidden Object & Adventure Editor</title>
  <script type="text/javascript" src="../js/base64.js"></script>
  <!--s cript type="text/javascript" src="js/itemstorage.js"></sc ript-->
  <script type="text/javascript" src="../js/painter.js"></script>
  <script type="text/javascript" id="datamodel_source">
//the basic datamodel
/**
@class Note
@param _uid
@since 2014-05-17
*/
function Note (_uid) {
 /***/
 this.uid = _uid;
 /***/
 this.text = null;
 /***/
 this.ex = 0;
 /***/
 this.ey = 0;
 /***/
 this.title = null;
 /***/
 this.connections = [];
 /***/
 this.load = function(data) {
  //console.log(data);
  for (var key in data) {
    if (key != 'connections' && key != null) {
    //console.log(key);
    if (typeof data[key] == 'Array') {
      //console.log('array'+ key+', '+data[key]);
      for (var i = 0; i < data[key]; i++) {
        if (typeof data[key][i].INSTANCE != 'undefined') {
          var func = new Function('return new '+data[key][i].INSTANCE+'('+data[key][i]['uid']+');');
          var obj = func();
          obj.load(data[key][i]);
          this[key][i] = obj;
        } else {
          this[key][i] = data[key][i];
        }
      } 
    } else {
      if (typeof data[key].INSTANCE != 'undefined') {
        //console.log(data[key].INSTANCE +'+'+ data[key]);
        var func = new Function('return new '+data[key][i].INSTANCE+'('+data[key]['uid']+');');
        var obj = func();
        obj.load(data[key][i]);
        this[key][i] = obj;
      } else if (data[key] != null) {
        //console.log(key +'-'+ (typeof data[key]));
        this[key] = data[key];
      }
    }
   }
  }
  //this.uid = data['uid'];
  this.connections = [];
  for (var i = 0; i < data['connections'].length;i++) {
   var connection = new Connection(data['connections'][i]['uid']);
   connection.load(data['connections'][i]);
   this.connections.push(connection);
  }
};
 /**
 */
 this.setEditorPos = function(x,y) {
  this.ex = x;
  this.ey = y;
 }
};
/**
@class Connection
@param _uid
@since 2014-05-17
*/
function Connection (_uid) {
 /***/
 this.uid = _uid;
 /***/
 this.text = null;
 /***/
 this.to_uid = null;
 /***/
 this.from_uid = null;
 /***/
 this.load = function(data) {
  for (var key in data) {
   //garanties that primitive values are loaded
   //a good replacement here
   this[key] = data[key];
  }
 };
};
/**
@class MediaLanguage
@param _lan
@since 2014-05-18
*/
function MediaLanguage(_lan) {
 /**
 @attribute language
 */
 this.language = _lan;
 /**
 @property medias
 */
 this.medias = [];
 /**
 @method load
 @param data
 @since 2014-05-29
 */
 this.load = function(data) {
  this.language = data['language'];
  this.medias = [];
  for (var i = 0; i < data['medias'].length; i++) {
   this.medias.push({ key:data['medias'][i]['key'], value:data['medias'][i]['value']});
  }
 };
 /**
 _t64 indicates if the value has to be base64_encoded or not
 @method setMedia
 @since 2014-05-15
 @param _k the key
 @param _v the value
 @param {boolean} _t64 to be 64 encoded
 */
 this.setMedia = function(_k, _v, _t64) {
  console.log('setMedia'+_k);
  if (this.hasMedia(_k)) {
   this.getMedia(_k).value = _t64 ? Base64.encode(_v): _v;
  } else {
   this.addMedia(_k, _v, _t64);
  }
 };
 /**
 use this to get Images, Audios, Videos and other
 media that should stay bas64 encoded
 var myMediaValue = [..].getMedia('key').value;
 @method getMedia
 @since 2014-05-15
 @param _k the key
 @return the complete media Object
 */
 this.getMedia = function(_k) {
  for (var i = 0; i < this.medias.length; i++) {
   if (this.medias[i].key == _k) {
    return this.medias[i];
   }
  }
  return null;
 };
 /**
 Don't use this method for images, audios or videos,
 because those have to stay base64_encoded
 @method getTextMedia
 @since 2014-05-15
 @param _k the key
 @return the media value - always base64 decoded
 */
 this.getTextMedia = function(_k) {
  for (var i = 0; i < this.medias.length; i++) {
   if (this.medias[i].key == _k) {
    //console.log('getMedia->'+Base64.decode(this.medias[i].value));
    return Base64.decode(this.medias[i].value);
   }
  }
  return null;
 };
 /**
 @method hasMedia
 @since 2014-05-15
 @param _k the key
 @return {boolean} true if the media with the key exists
 */
 this.hasMedia = function(_k, _v) {
  for (var i = 0; i < this.medias.length; i++) {
   if (this.medias[i].key == _k) {
    return true;
   }
  }
  return false;
 };
 /**
 @method deleteMedia
 @since 2014-05-16
 @param _k the key
 */
 this.deleteMedia = function(_k, _v) {
  for (var i = 0; i < this.medias.length; i++) {
   if (this.medias[i].key == _k) {
    return this.medias.splice(i, 1);
   }
  }
 };
 /**
 @method addMedia
 @since 2014-05-15
 @param _k the key
 @param _v the value
 @param {boolean} _t64 to be 64 encoded
 */
 this.addMedia = function(_k, _v, _t64) {
  this.medias.push(this.createMedia(_k, _v, _t64));
 };
 /**
 @method createMedia
 @since 2014-05-15
 @param _k the key
 @param _v the value
 @param {boolean} _t64 to be 64 encoded
 @return the media Object
 */
 this.createMedia = function(_k, _v, _t64) {
  _v = _t64 ? Base64.encode(_v): _v;
  return { key : _k, value : _v };
 };
};
/**
The Game class
@class Game
@since 2014-05-17
*/
function Game() {
 /**
 the major data type array
 @parameter notes
 @since 2014-05-17
 */
 this.notes = [];
 /**
 @parameter startNote
 @since 2014-05-29
 */
 this.startNote = null;
 /**
 @method load
 @since 2014-05-17
 */
 this.load = function(data) {
   if (data == null) {
    data = window.localStorage.getItem('game_data');
    data = JSON.parse(data);
    if (data == null) {
     //avoid a cannot read property exception
     //
     return;
    }
   }
   console.log('game-load');
   //console.log(data);
   for (var key in data) {
    //console.log(key, data[key]);
    if (key != null && data[key] != null && 
        key != 'mediamanager' && 
        key != 'startNote' && 
        key != 'notes') 
    {
     if (typeof data[key] == 'Array') {
      //console.log('array'+ key+', '+data[key]);
      for (var i = 0; i < data[key]; i++) {
        if (typeof data[key][i].INSTANCE != 'undefined') {
          var func = new Function('return new '+data[key][i].INSTANCE+'('+data[key][i]['uid']+');');
          var obj = func();
          obj.load(data[key][i]);
          this[key][i] = obj;
        } else {
          this[key][i] = data[key][i];
        }
      } 
     } else {
      if (typeof data[key].INSTANCE != 'undefined') {
        //console.log(data[key].INSTANCE +'+'+ data[key]);
        var func = new Function('return new '+data[key][i].INSTANCE+'('+data[key]['uid']+');');
        var obj = func();
        obj.load(data[key][i]);
        this[key][i] = obj;
      } else if (data[key] != null) {
        //console.log(key +'-'+ (typeof data[key]));
        this[key] = data[key];
      }
     }
    }
   }
   this.mediamanager.load(data['mediamanager']);
   this.startNote = data['startNote'];
   this.notes = [];
   for (var i = 0; i < data['notes'].length;i++) {
    var note = new Note(data['notes'][i]['uid']);
    note.load(data['notes'][i]);
    this.notes.push(note);
   }
 };
 /**
 @method save
 @since 2014-05-17
 */
 this.save = function() {
  var data = JSON.stringify(this);
  console.log('save data:');
  console.log(data);
  console.log(':save data');
  return data;
  //window.localStorage.setItem('game_data', data);
 };
 /**
 @class mediamanager
 @since 2014-05-18
 */
 this.mediamanager = {
  /**
  @property defaultLananguage
  @default 'en'
  */
  defaultLanguage : 'en',
  /**
  @property currentLanguage
  @default 'en'
  */
  currentLanguage : 'en',
  /**
  @property {array} languages
  */
  languages : [],
  /**
  @property {array} mediaLanguages
  */
  mediaLanguages : [],
  /**
  @method setCurrentLanguage
  */
  setCurrentLanguage : function(_lan) {
   this.currentLanguage = _lan;
   if (!this.hasLanguage(_lan)) {
    this.addLanguage(_lan);
   }
  },
  /**
  @method addLanguage
  */
  addLanguage : function(_lan) {
   this.mediaLanguages.push( new MediaLanguage(_lan) );
   this.languages.push(_lan);
  },
  /**
  @method hasLanguage
  */
  hasLanguage : function(_lan) {
   for (var i = 0; i < this.languages.length; i++) {
    if (this.languages[i] == _lan) {
     return true;
    }
   }
   return false;
  },
  /**
  @method getLanguage
  @since 2014-07-31
  @param _lan a language key like 'en','de',...
  @return {MediaLanguage} a mediaLanguage or null
  */
  getLanguage : function(_lan) {
   for (var i = 0; i < this.mediaLanguages.length; i++) {
    if (this.mediaLanguages[i].language == _lan) {
     return this.mediaLanguages[i];
    }
   }
   return null;
  },
  /**
  @method getCurrentLanguage
  */
  getCurrentLanguage : function() {
   for (var i = 0; i < this.mediaLanguages.length; i++) {
    if (this.mediaLanguages[i].language == this.currentLanguage) {
     return this.mediaLanguages[i];
    }
   }
   this.currentLanguage = this.defaultLanguage;
   var language = new MediaLanguage(this.currentLanguage);
   this.mediaLanguages.push( language );
   this.languages.push(this.currentLanguage);
   return language;
  },
  /**
  returns the keys, defined by the default language
  @method getKeys
  @since 2914-07-31
  @return {Array} keys 
  */
  getKeys : function () {
    var d_lan = this.getLanguage(this.defaultLanguage);
    var keys = [];
    for (var i = 0; i < d_lan.medias.length; i++) {
      //console.log(d_lan.getMedia(d_lan.medias[i].key).value.substr(0, 20));
      if (!(d_lan.getMedia(d_lan.medias[i].key).value.indexOf('data:') == 0 &&
          d_lan.getMedia(d_lan.medias[i].key).value.indexOf('base64') > 0))
      {
        keys.push(d_lan.medias[i].key);
      }
    }
    return keys;
  },
  /**
  use getTextMedia too get the decoded media value
  @method setTextMedia
  @since 2014-05-17
  @param _k the key
  @param _v the value
  */
  setTextMedia : function(_k, _v) {
   //type64=true|false would regulate de/encoding or not
   this.getCurrentLanguage().setMedia(_k, _v, true);
  },
  /**
  push through for MediaLanguage.setMedia
  the media will not be base64 encoded
  use getMedia too get the media
  use for Images and other natually base64 encoded media
  @method setMedia
  @since 2014-05-29
  @param _k the key
  @param _v the value - already base64 encoded
  */
  setMedia : function(_k, _v) {
   //type64=true|false would regulate de/encoding or not
   this.getCurrentLanguage().setMedia(_k, _v, false);
  },
  deleteMedia : function(_k) {
   for (var i = 0; i < this.mediaLanguages.length; i++) {
    this.mediaLanguages[i].deleteMedia(_k);
   }
  },
  getMedia : function(_k) {
   return this.getCurrentLanguage().getMedia(_k);
  },
  getTextMedia : function(_k) {
   return this.getCurrentLanguage().getTextMedia(_k);
  },
  /**
  @method load
  @param data
  @since 2014-05-29
  */
  load : function(data) {
   this.defaultLanguage = 'en',
   this.currentLanguage = data['currentLanguage'];
   this.languages = data['languages'];
   this.mediaLanguages = [];
   for (var i = 0; i < data['mediaLanguages'].length; i++) {
    var lan = new MediaLanguage(data['mediaLanguages'][i]['uid']);
    lan.load(data['mediaLanguages'][i]);
    this.mediaLanguages.push(lan);
   }
  }
 }
}
/**
@property game
@since 2014-05-28
*/
//var game = new Game();

  </script>
  <script>
  /**
  creates and stores unique ids
  @class UidCounter
  @since 2014-08-13
  */
  function UidCounter() {
    this.counters = [];
    this.abc = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';

    this.createNew = function(){
      var c = '';
      while(c == '' || this.hasCounter(c)) {
        c = '';
        for (var i = 0; i < 5; i++) {
          c = c + this.abc.substr(Math.floor(Math.random() * this.abc.length),1);
        }
      }
      this.counters.push(c);
      return c;
    };

    this.hasCounter = function(_c){
      for (var i = 0; i < this.counters.length; i++) {
        if (_c == this.counters[i]) {
          return true;
        }
      }
      return false;
    };
  };

  /**
  @class StoryGame
  @since 2014-08-13
  */
  function StoryGame() {
    Game.call(this);
    this.INSTANCE = 'StoryGame';
    this.title = null;//used for settings
    this.startScene = null; // a reference uid
    this.currentFigure = null; //possible start figure
    this.scenes = [];
    this.status = null;
    this.figures = [];
    //this.settings = [];//an array of functions, rules , scripts to perform?
    //this.code = null; //should be base64 encoded
  }
  StoryGame.prototype = new Game();
  StoryGame.prototype.INSTANCE = 'StoryGame';

  /**
  @class Scene
  @since 2014-08-13
  @param _uid
  */
  function Scene(_uid) {
    Note.call(this,_uid);
    this.INSTANCE = 'Scene';
    this.uid = _uid;
    this.name = null;
    this.status = null;
    this.background = null;
    this.objects = [];
  };
  Scene.prototype = new Note();
  //Scene.prototype.INSTANCE = 'Scene';

  /**
  @class GameObject
  @since 2014-08-13
  @param _uid
  */
  function GameObject(_uid) {
    Note.call(this,_uid);
    this.INSTANCE = 'GameObject';
    this.uid = _uid;
    this.name = null;
    this.image = null;
    this.width = 0;
    this.height = 0;
    this.posX = 0;
    this.posY = 0;
    this.status = null;
    this.isItem = false;//if true you can pickup the item

    this.isClicked = function(_x, _y) {
      return (this.posX <= _x && this.posY <= _y && _x <= this.posX + this.width && _y <= this.posY + this.height);
    };

    this.getBounds = function() {
      return {x: this.posX,y: this.posY,w: this.width,h: this.height};
    };

    this.intersects = function(_r) {
      return (
        (this.posX <= _r.x && this.posY <= _r.y && _r.x <= this.posX + this.width && _r.y <= this.posY + this.height) ||
        (this.posX <= _r.x + _r.w && this.posY <= _r.y && _r.x <= this.posX + this.width && _r.y + _r.h <= this.posY + this.height) ||
        (this.posX <= _r.x + _r.w && this.posY <= _r.y + _r.h && _r.x + _r.w <= this.posX + this.width && _r.y + _r.h <= this.posY + this.height) ||
        (this.posX <= _r.x  && this.posY <= _r.y + _r.h && _r.x + _r.w <= this.posX + this.width && _r.y <= this.posY + this.height) ||
        (this.posX <= _r.x + _r.w/2 && this.posY <= _r.y + _r.h/2 && _r.x + _r.w/2 <= this.posX + this.width && _r.y + _r.h/2 <= this.posY + this.height) ||
        (this.posX >= _r.x  && this.posY >= _r.y && _r.x >= this.posX + this.width && _r.y <= this.posY + this.height) ||
        (this.posX >= _r.x + _r.w && this.posY >= _r.y && _r.x + _r.w >= this.posX + this.width && _r.y <= this.posY + this.height) ||
        (this.posX >= _r.x + _r.w && this.posY >= _r.y + _r.h && _r.x + _r.w >= this.posX + this.width && _r.y + _r.h <= this.posY + this.height) ||
        (this.posX >= _r.x && this.posY >= _r.y + _r.h && _r.x >= this.posX + this.width && _r.y + _r.h <= this.posY + this.height) 
      );
    };
  };

  
  /**
  @class Figure
  @since 2014-08-13
  @param _uid
  */
  function Figure(_uid) {
    GameObject.call(this,_uid);
    this.INSTANCE = 'Figure';
    this.uid = _uid;
    this.bag = [];
    this.status = null;
    this.isPlayable = false;
    this.oldX = 0;
    this.oldY = 0;
    this.mx = 0;
    this.my = 0;
    this.copyParentKeys = function(gobj) {
      for (key in gobj) {
        this[key] = gobj[key];
      }
    };
  }

  Figure.prototype = new GameObject();
  Figure.prototype.moveTo = function(x,y) { this.mx = x; this.my = y; this.oldX = this.posX;  this.oldY = this.posY;}
  Figure.prototype.INSTANCE = 'Figure';

  var game = new StoryGame();
  var ctx = null;
  var cvs = null;
  var update = true;
  var pressed = false;
  var currentObject = null;
  var currentScene = null;
  var backtexture = null;
  //var scenes = [];
  //var title = 'projectTitle';
  /**
  @method init
  @since 2014-08-13
  */
  function init() {
    uidcounter = new UidCounter();
    /*if (!window.localStorage) {
      storage.indexedDB.open();
      window.localStorage = storage.indexedDB;
    }*/
    //var value = prompt('load game project?');
    //request dialog load project yes/create new
    //and init game + mediamanager
    game = new StoryGame();
    /*if (value != null && value.trim() != '') {
      //console.log(value, window.localStorage);
      var data = window.localStorage.getItem(value);
      console.log(data);
      if (data != null) {
        game.load(JSON.parse(data));
      }
    }*/
    cvs = getElement('canvas');
    cvs.width = 640;
    cvs.height = 360;
    ctx = cvs.getContext('2d');
    cvs.addEventListener('mousedown', function(evt) { mousePressed(evt.pageX, evt.pageY); }, true);
    cvs.addEventListener('mousemove', function(evt) { mouseMoved(evt.pageX, evt.pageY); }, true);
    cvs.addEventListener('mouseup', function(evt) { mouseReleased(evt.pageX, evt.pageY); }, true);
    if (backtexture == null) {
      drawBackTexture();
      cvs.style.background = 'url('+backtexture+')';
    }
    requestAnimationFrame(function() {updateCtx(Date.now())});
  };
  /**
  @method drawBackTexture
  @since 2014-08-16
  */
  function drawBackTexture() {
    var tvs = createElement('canvas');
    tvs.width = 20;
    tvs.height = 20;
    var tx = tvs.getContext('2d');
    tx.fillStyle = '#bbb';
    tx.fillRect(0,0,20,20);
    tx.fillStyle = '#eee';
    tx.fillRect(0,0,10,10);
    tx.fillRect(10,10,10,10);
    backtexture = tvs.toDataURL('painter.image/png');
  }
  /**
  @method setImage
  @since 2014-08-16
  @param _uid
  @param _mode
  */
  function setImage(_uid, _mode) {
    if (_mode != 'normal') {
      switch (_mode) {
        case 'painter':
          currentScene.background = _uid;
        break;
        case 'object':
          currentObject.image = _uid;
        break;
        default:
        break;
      }
    }
  }
  /**
  @method mousePressed
  @since 2014-08-13
  @param x
  @param y
  */
  function mousePressed(x,y) {
    if (!pressed) {
      if (mode != 'normal') {
        painter.mousePressed(x,y);
        pressed = true;
      } else {
        if (currentScene == null) {
          alert('create a new scene first.');
          return;
        }
        pressed = true;
        if (currentObject == null) {
          currentObject = new GameObject(uidcounter.createNew());
          currentObject.posX = x;
          currentObject.posY = y;
          //request dialog for input of the name

        } else {
          
        }
      }
      update = true;
    }
  };
  /**
  @method mouseMove
  @since 2014-08-13
  @param x
  @param y
  */
  function mouseMoved(x,y) {
    if (pressed) {
      if (mode != 'normal') {
        painter.mouseMoved(x,y);
      } else {
        if (x < currentObject.posX) {
         currentObject.width = Math.abs(currentObject.posX - x) + currentObject.width;
         currentObject.posX = x;
        } else {
         currentObject.width = Math.abs(currentObject.posX - x);
        }
        if (y < currentObject.posY) {
         currentObject.height = Math.abs(currentObject.posY - y) + currentObject.height;
         currentObject.posY = y;
        } else {
         currentObject.height = Math.abs(currentObject.posY - y);
        }
      }
    }
    update = true;
  };
  /**
  @method mouseReleased
  @since 2014-08-13
  @param x
  @param y
  */
  function mouseReleased(x,y) {
    if (pressed) {
      if (mode != 'normal') {
        painter.mouseReleased(x,y);
      } else {
        currentObject.width = Math.abs(currentObject.posX - x);
        currentObject.height = Math.abs(currentObject.posY - y);
        currentScene.objects.push(currentObject);
        addObject(currentObject);
        currentObject = null;
      }
      pressed = false;
      update = true;
    }
  };
  /**
  @method addObject
  @since 2014-08-15
  @param _obj
  */
  function addObject(_obj) {
    //adds the currentObject to the objects div-list
    //or all objects of the current scene + figures of the game.
    var child = createElement('div');
    child.className = 'menuObject';
    //child.style.borderBottom = '1px solid #999';
    child.appendChild(createTextNode(_obj.uid));
    child.setAttribute('id','obj_'+_obj.uid);
    child.setAttribute('data-uid',_obj.uid);//obsolete?!
    child.setAttribute('onclick','showObjectMenu(\''+_obj.uid+'\');');
    getElement('objects').appendChild(child);
  }
  /**
  @method deleteObject
  @since 2014-08-17
  @param _uid
  */
  function deleteObject(_uid) {
    var scenes = game.scenes;
    for (var j = 0; j < scenes.length; j++) {
      var objects = scenes[j].objects;
      for ( var i = 0; i < objects.length; i++) {
        if (objects[i].uid == _uid) {
          objects.splice(i, 1);
        }
      }
    }
    document.body.removeChild(getElement('objectmenu'));
    update = true;
  }
  /**
  @method editObject
  @since 2014-08-17
  @param _uid
  */
  function editObject(_uid, data) {
    var obj = getObject(_uid);
    if (data == null) {
        
    } else {
    
    }
  }
  /**
  @method showObjectMenu
  @since 2014-08-15
  @param _uid
  */
  function showObjectMenu(_uid) {
    //get the object from the current scene
    if (getElement('objectmenu') != null) {
      document.body.removeChild(getElement('objectmenu'));
    }
    var menu = createElement('div');
    menu.setAttribute('id','objectmenu');
    menu.style.position = 'absolute';
    menu.style.left = '440px'; 
    menu.style.top = (getElement('obj_'+_uid).offsetTop-50)+'px'; 
    menu.style.background = '#fff';
    menu.style.boxShadow = '0 0 1px #999, 15px 15px 25px #999';
    menu.style.width = '200px';
    menu.style.zIndex = 1000;
    var field = createElement('fieldset');
    var child = createElement('legend');
    child.appendChild(createTextNode('object menu '+_uid));
    field.appendChild(child);
    child = createElement('button');
    child.setAttribute('onclick','editObject(\''+_uid+'\');');
    child.appendChild(createTextNode('edit'));
    field.appendChild(child);
    child = createElement('button');
    child.setAttribute('onclick','painter.drawObjectImage(\''+_uid+'\');');
    child.appendChild(createTextNode('image'));
    field.appendChild(child);
    child = createElement('button');
    child.setAttribute('onclick','deleteObject(\''+_uid+'\');');
    child.appendChild(createTextNode('delete'));
    field.appendChild(child);
    field.appendChild(createTextNode('set object\'s properties:'));
    field.appendChild(createElement('br'));
    var c = ['collectable','figure','playable','canleavescene','isclicked','intersects'];
    for (var i = 0; i < c.length; i++) {
      child = createElement('span');
      child.setAttribute('id', 'p_'+c[i]+'_s');
      child.style.marginBottom = '2px'; 
      child.style.display = 'block'; 
      child.style.padding = '2px 5px 2px 5px';
      child.style.background = 'firebrick'; 
      child.style.color = 'white';
      field.appendChild(child);
      var child2 = createElement('input');
      child2.setAttribute('type','checkbox');
      child2.setAttribute('id','p_'+c[i]);
      child2.setAttribute('name',c[i]);
      child2.setAttribute('onchange','document.getElementById(this.id+\'_s\').style.background = this.checked ? \'green\':\'firebrick \'');
      child.appendChild(child2);
      child.appendChild(createTextNode(c[i]));
    }
    child = createElement('button');
    child.setAttribute('onclick','var properties = {collectable:false, figure:false, playable:false, canleavescene:false, isclicked:false, intersects:false}; var ins = objectmenu.querySelectorAll(\'input\'); for (var i = 0; i < ins.length; i++) { if (ins[i].checked)properties[ins[i].name]=ins[i].checked; }; /*console.log(properties);*/ setObjectProperties(\''+_uid+'\',properties); document.body.removeChild(getElement(\'objectmenu\')); return false;');
    child.appendChild(createTextNode('done'));
    field.appendChild(child);
    menu.appendChild(field);
    document.body.appendChild(menu);	
  }
  /**
  @method setObjectProperties
  @since 2014-08-16
  @param _uid
  @param _props
  */
  function setObjectProperties(_uid, _props) {
    var obj = getObject(_uid);
    if (obj == null) {
      document.body.removeChild(getElement('objectmenu'));
    }
    //console.log(_props);   
    if (_props.figure) {
      for (key in _props) {
        if (key != null) {
          obj[key] = _props[key];
        }
      }
      var fig = new Figure(_uid);
      fig.copyParentKeys(obj);
      obj = fig;
    } else {
      var o = new GameObject();
      for (key in _props) {
        if (key != null) {
          o[key] = _props[key];
        }
      }
      for (var key in o) {
        o[key] = obj[key];
      }
      obj = o;
    }
    console.log(obj);
    setObject(_uid, obj);
    update = true;
  }
  /**
  @method setObject
  @since 2014-08-16
  @param _uid
  @param _obj
  */
  function setObject(_uid, _obj) {
    var scenes = game.scenes;
    for (var j = 0; j < scenes.length; j++) {    
      var objects = scenes[j].objects;
      for (var i = 0; i < objects.length; i++) {
        if (objects[i].uid == _uid) {
          objects[i] = _obj;
        }
      }
    }
    return null;
  }
  /**
  @method getObject
  @since 2014-08-15
  @param _uid
  */
  function getObject(_uid) {
    var scenes = game.scenes;
    for (var j = 0; j < scenes.length; j++) {    
      var objects = scenes[j].objects;
      for (var i = 0; i < objects.length; i++) {
        if (objects[i].uid == _uid) {
          return objects[i];
        }
      }
    }
    return null;
  }
  /**
  @method newScene
  @since 2014-08-14 
  */
  function newScene() {
    //create a new scene
    //and add it to the scenes array
    currentScene = new Scene(uidcounter.createNew());
    game.scenes.push(currentScene);
    addScene(currentScene);
    selectScene(currentScene.uid);
  }
  /**
  @method addScene
  @since 2014-08-14
  @param _scn
  */
  function addScene(_scn) {
    //create the option
    var option = createElement('option');
    option.appendChild(createTextNode(_scn.uid));
    option.setAttribute('value', _scn.uid);
    option.setAttribute('id', 'scn_'+_scn.uid);
    getElement('scenes').appendChild(option);
  };
  /**
  @method editScene
  @since 2014-08-14
  */
  function editScene() {
    //edit the currentScene
    //set the title or decription/text in mediamanger / reference -> Note
    //upload and set background image and reference
    //update the corresponding option for the current scene?
  };
  /**
  @method deleteScene
  @since 2014-08-15
  */
  function deleteScene() {
    //delete the currentScene
    if (currentScene != null) {
      //dialog('do you want to remove this scene forever?','yes','no');
      getElement('scenes').removeChild(getElement('scn_'+currentScene.uid));
      var scenes = game.scenes;
      for (var i = scenes.length-1; i >= 0; i--) {
        if (scenes[i].uid == currentScene.uid) {
          scenes.splice(i,1);
        }
      }
      getElement('objects').innerHTML = '';
    }
    update = true;
  };
  /**
  @method selectScene
  @since 2014-08-14
  @param value
  */
  function selectScene(value) {
    //get the selected value from id scenes
    if (value == null) {
      value = getElement('scenes').value;
      console.log(value);  
    }
    if (value == '---') {
      return;
    }
    currentScene = getScene(value);
    //console.log(currentScene, value);
    getElement('objects').innerHTML = '';
    var objects = currentScene.objects;
    for (var i = 0; i < objects.length; i++) {
      addObject(objects[i]);
    }
    update = true;
  };
  /**
  @method getScene
  @since 2014-08-15
  @param _uid
  */
  function getScene(_uid) {
    var scenes = game.scenes;
    for (var i = scenes.length-1; i >= 0; i--) {
      if (scenes[i].uid == _uid) {
        return scenes[i];
      }
    }
    return null;
  };
  /**
  @method setGameSetting
  @since 2014-08-17
  @param data
  */
  function setGameSetting(data) {
    if (data == null) {
      //set the title of the game
      //etc
      var ele = createElement('div');
      ele.setAttribute('id','propertiesBox');
      ele.style.position = 'absolute';
      ele.style.left = '10px';
      ele.style.top = '10px';
      ele.style.zIndex = '1000';
      ele.style.width = '200px';
      ele.style.background = '#eee';
      ele.style.boxShadow = '0 0 2px #999, 15px 15px 25px #999';
      document.body.appendChild(ele);
      /*
      this.title = null;//used for settings
      this.startScene = null; // a reference uid
      this.currentFigure = null; //possible start figure
      this.scenes = [];
      this.status = null;
      this.figures = [];
      */
      ele.appendChild(createTextNode('game title:'));
      var child = document.createElement('input');
      child.value = game.mediamanager.getTextMedia(game.title);
      child.setAttribute('id','game_title');
      ele.appendChild(child);
      child = createElement('button');
      child.appendChild(createTextNode('done'));
      child.setAttribute('onclick','setGameSetting(getElement(\'game_title\').value);');
      ele.appendChild(child);
    } else {
      game.title = uidcounter.createNew();
      game.mediamanager.setTextMedia(game.title ,data);
      document.body.removeChild(getElement('propertiesBox'));
    }
  };
  /**
  @method loadGameSetting
  @since 2014-08-17
  @param data
  */
  function loadGameSetting(data) {
    if (window.localStorage)
    if (data == null) {
      try {
        var pros = localStorage.getItem('projects');
        if (pros == null) {
          pros = [];
        } else {
          pros = JSON.parse(pros);
        }
        var ele = createElement('div');
        ele.setAttribute('id','propertiesBox');
        ele.style.position = 'absolute';
        ele.style.width = '200px';
        ele.style.left = '10px';
        ele.style.top = '10px';
        ele.style.zIndex = '1000';
        ele.style.background = '#eee';
        ele.style.boxShadow = '0 0 2px #999, 15px 15px 25px #999';
        document.body.appendChild(ele);
        var child = null;
        for (var i = 0; i < pros.length; i++) {
          if (pros[i] == title) {
            pros.splice(i, 1);
          } else {
            child = createElement('div');
            child.className = 'pb_game';
            child.appendChild(createTextNode(pros[i].title));
            var title = pros[i].title;
            //title = title.replace(/[^a-zA-Z0-9]+/g,'');
            child.setAttribute('onclick', 'loadGameSetting(\''+pros[i].title+'\');');
            ele.appendChild(child);
          }
        }
        child = createElement('button');
        child.appendChild(createTextNode('close'));
        child.setAttribute('onclick','document.body.removeChild(getElement(\'propertiesBox\'));');
        ele.appendChild(child);
      } catch (ex) {
        alert('nothing to load');
      }
    } else {
      try {
        var title = data;
        console.log('title='+title);
        data = JSON.parse(localStorage.getItem('project_'+title));
        console.log(data);
        game = new StoryGame();
        game.load(data);
        data = JSON.parse(localStorage.getItem('uidcounter_'+title));
        uidcounter.counters = data.counters;
        console.log(game);
        getElement('scenes').innerHTML = '<option value="---">---</option>';
        for (var i = 0; i < game.scenes.length; i++) {
          addScene(game.scenes[i]);
        }
        currentScene = game.scenes[0];
        selectScene(currentScene.uid);
        update = true;
        document.body.removeChild(getElement('propertiesBox'));
      } catch (ex) {
        console.log(game);
        alert('loading failed '+data);
      }
    }
  };
  /**
  @method saveGameSetting
  @since 2014-08-17
  @param data
  */
  function saveGameSetting(data) {
    if (window.localStorage) {    
      try {
        if (game.title == null || game.title == '') {
          alert('set game title first');
          setGameSetting();
          return;
        }
        var title = game.mediamanager.getTextMedia(game.title);
        title = title.replace(/[^a-zA-Z0-9]+/g,'');
        console.log(game.save());
        localStorage.setItem('project_'+title, game.save());
        localStorage.setItem('uidcounter_'+title, JSON.stringify(uidcounter));
        var pros = localStorage.getItem('projects');
        if (pros == null) {
          pros = [];
        } else {
          pros = JSON.parse(pros);
        }
        var b = false;
        for (var i = 0; i < pros.length; i++) {
          if (pros[i].title == title) {
            b = true;
            //pros.splice(i, 1);
          }
          if (pros[i] == title) {
            pros.splice(i, 1);
          }
        }
        if (!b) {
          pros.push( {title: title, uid: game.title} );          
        }
        localStorage.setItem('projects', JSON.stringify(pros));
      } catch (ex) {
        alert('saving project '+data+' failed');
      }
    }
  };
  /**
  @method importSetting
  @since 2014-08-17
  @param data
  */
  function importSetting() {
  
  };
  /**
  @method exportSetting
  @since 2014-08-17
  @param data
  */
  function exportSetting() {
  
  };

  function getElement(id) {
    return document.getElementById(id);
  };
  function createElement(id) {
    return document.createElement(id);
  };
  function createTextNode(txt) {
    return document.createTextNode(txt);
  };
  /**
  @method updateCtx
  @since 2014-08-14
  @param _time
  */
  function updateCtx(_time) {
    //console.log(mode);
    switch (mode) {
      case 'painter':
      if (update) {
        painter.updatePainter(_time);
      }
      break;
      default:
      if (update) {
        draw(_time);
      }
      break;
    } 
    requestAnimationFrame(function() {updateCtx(Date.now());});
  }
  /**
  @method draw
  @since 2014-08-14
  @param _time
  */
  function draw(_time) {
    if (backtexture == null) {
      drawBackTexture();
      cvs.style.background = 'url('+backtexture+')';
    }    
    ctx.clearRect(0,0,cvs.width,cvs.height);
    ctx.fillStyle = '#09c';
    ctx.font = '12px sans-serif';
    ctx.strokeStyle = '#09c';
    ctx.lineWidth = 2;
    if (currentScene != null) {
      var img = new Image();
      if (currentScene.background != null) {
        img.src = game.mediamanager.getMedia(currentScene.background).value;
        ctx.drawImage(img, 0,0, cvs.width,cvs.height);
      }
      var objects = currentScene.objects;
      var obj = null;
      for (var i = 0; i < objects.length; i++) {
        obj = objects[i];
        if (obj instanceof Figure) {
          ctx.fillStyle = '#0c0';
          if (obj.playable != null && obj.playable) {
            ctx.fillStyle = '#ff0';
          }
          ctx.strokeStyle = '#0c0';
        } else if (obj.collectable != null && obj.collectable) {
          ctx.fillStyle = '#ff0';
          ctx.strokeStyle = '#ff0';
        } else {
          ctx.fillStyle = '#09c';
          ctx.strokeStyle = '#09c';
        }
        var obj = objects[i];
        if (obj.image != null) {
          img.src = game.mediamanager.getMedia(obj.image).value;
          ctx.drawImage(img, obj.posX,obj.posY,obj.width,obj.height);
        }
        ctx.strokeRect(obj.posX,obj.posY,obj.width,obj.height);
        ctx.fillText(obj.name==null?obj.uid:obj.name,obj.posX+3,obj.posY+15);
      }
      ctx.fillStyle = '#f00';
      ctx.strokeStyle = '#f00';
      if (currentObject != null) {
        if (currentObject.image != null) {
          img.src = game.mediamanager.getMedia(currentObject.image).value;
          ctx.drawImage(img, currentObject.posX,currentObject.posY,currentObject.width,currentObject.height);
        }
        ctx.strokeRect(currentObject.posX,currentObject.posY,currentObject.width,currentObject.height);
        ctx.fillText(currentObject.name==null?currentObject.uid:currentObject.name,currentObject.posX+3,currentObject.posY+15);
      }
    }
  } 

  window.onload = function() {setTimeout(init,100);};
  </script>
  <style>
  body, div, canvas, button, span, p, br {margin: 0; padding: 0; font-family: sans-serif; font-size: 12px;}
  body, div, button, span, p, br {
    -moz-user-select: -moz-none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -o-user-select: none;
    user-select: none;
  }
  button {float: left; width: 33%;background:#333;color:#fff;border:1px solid #fff;}
  button:hover {background:#eee;border:1px solid #999;color:#000;}
  #canvas {float: left; width: 640px; height: 360px; background: #000;}
  #settings {width: 200px;}
  #scenes {width: 200px;}
  #objects {width: 200px;overflow: scroll;}
  .pb_game { background:#333;color:#fff;padding:5px;border:1px solid #fff;}
  .pb_game:hover { background:#eee;border:1px solid #999;color:#000;}
  .menuObject {background:#fff;color:#333;padding:5px;border:1px solid #999;}
  .menuObject:hover {background:#eee;border:1px solid #999;color:#000;}
  </style>
 </head>
 <body>
  <canvas id="canvas"></canvas>
  <div style="float: left; width: 200px; min-height: 360px;max-height360px;">
  <button id="setgame" onclick="setGameSetting();">set</button>
  <button id="savegame" onclick="saveGameSetting();">save</button>
  <button id="loadgame" onclick="loadGameSetting();">load</button>
  <button id="sceneimage" onclick="painter.init();">new img</button>
  <button id="painterpalette" onclick="painter.openPalette();">palette</button>
  <button id="painterpalette" onclick="painter.deactivate();">set img</button>
  <br>
  <select id="scenes" onchange="selectScene();"><option value="---">---</option></select>
  <button onclick="editScene();">edit</button>
  <button onclick="deleteScene();">delete</button>
  <button onclick="newScene();">new</button>
  <hr>
  <div id="objects"></div>
  </div>
 </body>
</html>
